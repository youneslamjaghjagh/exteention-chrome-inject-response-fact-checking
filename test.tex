


\chapter{Mise en ≈ìuvre du projet}
\section*{Introduction}
Ce troisi√®me chapitre se concentre sur la phase de mise en ≈ìuvre du projet. Il pr√©sente la mise en ≈ìuvre des √©l√©ments d√©finis lors de la phase de conception dans une structure claire. L'accent est mis sur l'architecture technique utilis√©e, les outils et technologies s√©lectionn√©s, ainsi que le processus de d√©veloppement. L'objectif est de montrer comment les sp√©cifications fonctionnelles et techniques pr√©alablement √©tablies sont devenues un syst√®me op√©rationnel, test√© et pr√™t √† l'emploi.
\section*{L'architecture technique}
L'architecture technique du dispositif, d√©j√† pr√©sent√©e au chapitre pr√©c√©dent, repose enti√®rement sur une architecture divis√©e en trois composants principaux : une extension Chrome int√©gr√©e au navigateur, un serveur back-end d√©velopp√© en Python/Flask et un serveur web d'IA h√©bergeant une version en langage avanc√©. Cette phase offre une vue d'ensemble de cette architecture, mettant en √©vidence les relations utiles entre les modules, ainsi que les choix technologiques suivis pour leur impl√©mentation.

\subsection*{Pr√©sentation}
Le syst√®me est con√ßu selon une architecture client-serveur. L'extension c√¥t√© client agit comme un capteur de contenu : elle d√©tecte les publications textuelles sur les r√©seaux sociaux (g√©n√©ralement Facebook), extrait le texte pertinent, puis lance une requ√™te de v√©rification. Cette requ√™te est transmise au serveur back-end, qui, √† son tour, traite les donn√©es et interagit avec un moteur d'analyse s√©mantique h√©berg√© localement sur la plateforme Ollama. Le r√©sultat est ensuite renvoy√© √† l'extension et inject√© discr√®tement dans l'interface utilisateur.

Ce fonctionnement repose sur des √©changes structur√©s, g√©n√©ralement au format JSON, transmis via des requ√™tes HTTP POST. Un cache local a √©galement √©t√© int√©gr√© √† l'extension afin de limiter les appels redondants et d'optimiser les performances de base.

\subsection*{Coordination des composants}
\begin{itemize}
    \item \textbf{Extension Chrome :} D√©tecte automatiquement les publications, extrait le texte, v√©rifie le cache, envoie les donn√©es au serveur et affiche les r√©sultats.
    \item \textbf{Backend Flask :} R√©ception des donn√©es, applique le traitement linguistique (techniques de NLP), g√©n√®re un d√©clencheur, interroge le moteur d'IA et renvoie une r√©ponse format√©e.
    \item \textbf{Serveur d'IA (Ollama) :} H√©berge une version LLaMA 3.2 charg√©e d'analyser le contenu et de fournir une analyse authentique.
\end{itemize}
Cette s√©paration des t√¢ches permet la maintenance du code et rend l'arc plus performant.
\section{Environnement et outils utilis√©s}
Cette phase d√©crit l'ensemble des outils, technologies et configurations mat√©rielles et logicielles ayant √©t√© mobilis√©s pour la mise en ≈ìuvre du projet. Elle couvre notamment les composants utilis√©s pour le d√©veloppement de l'extension Chrome, la mise en place du serveur backend, ainsi que l'int√©gration d'un syst√®me d'analyse de contenu bas√© sur l'intelligence artificielle.

Le d√©veloppement s'est appuy√© sur un environnement local compos√© d'un navigateur Google Chrome pour le d√©ploiement de l'extension, d'un serveur local en Python pour la partie traitement, et d'un serveur annexe d√©di√© √† l'h√©bergement d'un mod√®le de langage pr√©-entra√Æn√© de type LLaMA 3.2. Ce mod√®le permet d'√©valuer la fiabilit√© des contenus textuels issus des publications Facebook.

L'extension, d√©velopp√©e en JavaScript, est responsable de la d√©tection des publications visibles sur la page web de l'utilisateur. Elle extrait le contenu textuel essentiel de chaque publication, puis l'envoie au backend local via une interface de programmation (API REST).

Ce backend, cod√© en Python, effectue un pr√©traitement du texte √† l'aide de techniques de traitement automatique du langage (NLP), avant de transmettre les donn√©es au serveur IA. Le serveur IA, o√π r√©side le mod√®le de v√©rification, analyse le contenu et retourne un verdict ou une √©valuation textuelle. Cette r√©ponse est ensuite renvoy√©e √† l'extension, qui la stocke temporairement dans un syst√®me de cache local pour √©viter des traitements redondants.

Enfin, l'extension injecte visuellement les r√©sultats d'analyse directement dans les publications concern√©es, sous forme d'√©l√©ments graphiques discrets mais informatifs. L'ensemble de cet environnement a √©t√© pens√© pour assurer une interaction fluide entre les diff√©rentes composantes, tout en maintenant une modularit√©.
\subsection{Environnement de d√©veloppement}
Le d√©veloppement du projet a √©t√© r√©alis√© sur un ordinateur personnel dot√© des caract√©ristiques techniques suivantes :

\begin{itemize}
    \item \textbf{Mod√®le :} Lenovo ThinkPad T480s
    \item \textbf{Processeur :} Intel Core i5‚Äì8350U, cadenc√© entre 1.70 GHz et 1.90 GHz
    \item \textbf{M√©moire vive (RAM) :} 24 Go
    \item \textbf{Syst√®me d'exploitation :} Windows 11, version 64 bits
    \item \textbf{Navigateur principal :} Google Chrome, avec des tests compl√©mentaires sur d'autres navigateurs bas√©s sur Chromium tels que Brave et Opera
\end{itemize}
Cette configuration s'est r√©v√©l√©e suffisante pour mener √† bien l'ensemble des phases de d√©veloppement et de test de l'extension. L'environnement permet notamment de simuler l'exp√©rience d'un utilisateur standard naviguant sur Facebook, ce qui a facilit√© la validation fonctionnelle de l'outil dans des conditions proches du r√©el.

L'extension Chrome d√©velopp√©e dans le cadre de ce projet a √©t√© test√©e principalement sur le site Facebook. Elle fonctionne de mani√®re fluide sur les navigateurs reposant sur Chromium. En revanche, une incompatibilit√© a √©t√© constat√©e avec Firefox et Microsoft Edge. Ces navigateurs imposent certaines limitations en mati√®re de gestion des extensions et d'acc√®s au mod√®le de s√©curit√© DOM, rendant le bon fonctionnement de l'outil incertain sur ces plateformes.
\begin{figure}[H]
    \centering
    \includegraphics[height=3cm, width=0.45\textwidth]{images/facebookimage.png} % Reduced width to accommodate two images
    \hfill % Add horizontal space between images
    \includegraphics[height=3cm, width=0.45\textwidth]{images/microsoft-windows-11-home.jpg} % Reduced width
    \caption{Logos: Facebook and Windows 11} % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
Pour la partie d√©veloppement, deux environnements de programmation principaux ont √©t√© utilis√©s :


Visual Studio Code (VS Code) :est un √©diteur de code hautement performant qui, associ√© √† l'ensemble des services de langage de programmation, offre la puissance d‚Äôun IDE et la rapidit√© d‚Äôun √©diteur de texte. Gr√¢ce √† un ensemble de fonctionnalit√©s intelligentes propres √† VS Code (suggestions, conseils de param√®tres, navigation intelligente dans le code), il constitue l‚Äô√©diteur de texte principal utilis√© dans notre projet. En s‚Äôappuyant sur l‚Äôensemble de ces outils, nous l‚Äôavons utilis√© pour impl√©menter et manipuler les diff√©rents fichiers li√©s √† notre extension, d√©velopp√©e √† l‚Äôaide des technologies HTML, CSS, JavaScript et JSON, dans le but d‚Äôint√©grer et de g√©rer efficacement le contenu de cette extension.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/code-stable.png} 
    \caption{Logos: Visual Studio Code } % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}

PyCharm est un IDE (environnement de d√©veloppement int√©gr√©) sp√©cialis√© dans le langage Python. Il offre une panoplie d'outils pour le d√©veloppement des projets Python ainsi que des projets dans des domaines connexes tels que le d√©veloppement web et le traitement des donn√©es.
Pour la partie backend du syst√®me, PyCharm a √©t√© mis √† contribution dans notre projet. Cet environnement a grandement facilit√© la mise en place d'un serveur Python, notamment gr√¢ce √† son int√©gration native avec le microframework Flask ainsi qu'avec les biblioth√®ques de NLP (NLP). PyCharm a permis une gestion efficace des d√©pendances, une meilleure organisation du code et un d√©bogage fluide, contribuant ainsi significativement √† la productivit√© et √† la stabilit√© du d√©veloppement backend.

\begin{figure}[H]
    \centering
    \includegraphics[height=3cm, width=0.5\textwidth]{images/PyCharm_Icon.svg} 
    \caption{Logos: PyCharm } % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\section{Outils, biblioth√®ques et technologies}
\subsection{Backend Python (serveur API)}
Le serveur backend du syst√®me a √©t√© d√©velopp√© en Python en utilisant le microframework \textbf{Flask}, reconnu pour sa l√©g√®ret√©, sa facilit√© de prise en main et sa compatibilit√© avec les architectures orient√©es microservices.

Ce serveur joue un r√¥le central dans le traitement automatis√© des publications textuelles extraites par l'extension Chrome. Lorsqu'un post est d√©tect√©, son contenu est transmis au backend, qui applique des techniques de \textbf{(NLP)} afin de structurer et analyser l'information. Ensuite, le serveur communique avec un module d'analyse local, bas√© sur un mod√®le pr√©-entra√Æn√© performant (\textbf{LLaMA 3.2}), afin d'√©valuer la v√©racit√© du contenu d√©tect√©.

Une fois l'analyse termin√©e, la r√©ponse g√©n√©r√©e est renvoy√©e √† l'extension, qui la stocke temporairement dans un cache local. Cette r√©ponse est ensuite inject√©e visuellement dans le post concern√©, avec un style adapt√©, permettant √† l'utilisateur de b√©n√©ficier d'un retour rapide et contextualis√© directement dans son fil d'actualit√©.
\begin{description}
\item\textbf{Python:}\newline La d√©cision d'utiliser Python comme principale technologie c√¥t√© serveur repose sur deux raisons principales : premi√®rement, sa grande compatibilit√© avec les environnements de d√©veloppement modernes et deuxi√®mement, sa capacit√© √† communiquer efficacement avec de grands mod√®les de langage (LLM), ce qui en fait un outil id√©al pour notre besoin d'int√©grer un syst√®me de v√©rification des faits pris en charge par l'IA. 
\begin{figure}[H]
    \centering
    \includegraphics[height=3cm, width=0.6\textwidth]{images/Python-Symbol.png} 
    \caption{Logos: Python Logo } % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\item\textbf{Flask:}\newline
Flask est un framework web l√©ger con√ßu pour le langage Python, souvent class√© parmi les ¬´ micro-frameworks ¬ª en raison de son approche minimaliste. Il met √† disposition les √©l√©ments fondamentaux n√©cessaires au d√©veloppement d‚Äôapplications web, sans imposer de structure complexe ni de composants superflus. Contrairement √† d'autres frameworks plus complets comme Django, Flask n‚Äôint√®gre pas de modules pr√©configur√©s tels que la gestion des utilisateurs ou une interface d‚Äôadministration. Cette souplesse permet aux d√©veloppeurs de ne retenir que les fonctionnalit√©s utiles √† leur projet, ce qui en fait un outil adapt√© aux architectures modulaires et personnalisables, comme celle mise en ≈ìuvre dans notre syst√®me.
\begin{figure}[H]
    \centering
    \includegraphics[height=3cm, width=0.5\textwidth]{images/flask-icon-797x1024-5a9evoph.png} 
    \caption{Logos: Flask Logo } % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\begin{description}
\item \textit{Repr√©sentation G√©n√©rale de Structure d'Architecture de Notre Serveur Backend}

\begin{itemize}
    \item \textbf{/backend}
    \begin{itemize}
        \item .venv/ \quad \textit{(Environnement virtuel Python isol√©)}
        \item moduls/ \quad \textit{(Dossier contenant les modules m√©tiers)}
        \begin{itemize}
            \item ClaimExtractor.py \quad \textit{(Extraction d'informations textuelles avec NLP)}
            \item Prompt.py \quad \textit{(G√©n√©ration de prompts pour l'IA √† partir du texte analys√©)}
            \item OllamaAPI.py \quad \textit{(Communication avec le serveur IA Ollama (mod√®le LLaMA 3.2))}
        \end{itemize}
        \item app.py \quad \textit{(Point d'entr√©e principal du serveur Flask (API REST))}
        \item requirements.txt \quad \textit{(Liste des biblioth√®ques Python utilis√©es)}
        \item README.md \quad \textit{(Documentation technique du backend)}
        \item .gitignore \quad \textit{(Fichiers ignor√©s par Git (ex : .venv, \_\_pycache\_\_))}
        \item Scratches and Consoles/ \quad \textit{(Espace temporaire PyCharm (non critique))}
        \item External Libraries/ \quad \textit{(Librairies install√©es (affichage via l'IDE))}
    \end{itemize}
    
\end{itemize}
\item \textit{Repr√©sentation Technique De Notre Code Impl√©ment√©} 
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/Screenshot 2025-06-21 133528.png} 
    \caption{app.py:D√©clarations et importations moduls} % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/Screenshot 2025-06-21 133753.png} 
    \caption{app.py: Code M√©canismes essentiels du Serveur} % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}

\subsubsection{ Description du Script et des Modules Import√©s}

Le programme est une application web bas√©e sur le microframework \textbf{Flask}. Il utilise plusieurs modules et classes, certains fournis par Flask, d‚Äôautres d√©velopp√©s sp√©cifiquement pour ce projet.

\begin{itemize}
    \item \textbf{Flask} : classe principale de l‚Äôapplication web, elle permet d‚Äôinstancier le serveur, d√©finir les routes, g√©rer les requ√™tes HTTP et configurer l‚Äôapplication.

    \item \textbf{\texttt{request}} : objet cl√© pour acc√©der aux donn√©es envoy√©es par le client, notamment le corps des requ√™tes (\texttt{json}, \texttt{form}, \texttt{data}), les param√®tres d‚ÄôURL, les en-t√™tes HTTP, la m√©thode utilis√©e (GET, POST) et l‚Äôadresse IP du client.

    \item \textbf{\texttt{jsonify}} : fonction de Flask qui transforme des objets Python (listes, dictionnaires) en r√©ponses HTTP JSON correctement format√©es, en ajoutant les en-t√™tes n√©cessaires et en assurant une s√©rialisation correcte.

    \item \textbf{Gestion CORS avec \texttt{flask\_cors}} : permet d‚Äôactiver les r√®gles CORS (Cross-Origin Resource Sharing) pour autoriser les requ√™tes HTTP provenant d‚Äôorigines diff√©rentes, ce qui est essentiel pour que des clients externes (comme une extension Chrome) puissent communiquer avec le backend Flask sans √™tre bloqu√©s par les navigateurs.

    \item \textbf{ClaimExtractor} : classe d√©velopp√©e dans le projet, d√©di√©e √† l‚Äôanalyse NLP des textes.

    \item \textbf{Prompt} : classe qui construit l‚Äôinvite finale destin√©e au mod√®le d‚ÄôIA.

    \item \textbf{OllamaAPI} : classe qui g√®re l‚Äôinteraction avec le mod√®le d‚ÄôIA, en formatant et transmettant les requ√™tes et r√©ponses.
\end{itemize}

\subsubsection*{M√©canisme Essentiel du Fonctionnement de l'Application}
Le m√©canisme principal du script d√©bute par l'appel √† la classe \textbf{Flask} pour instancier l'objet repr√©sentant l'application. Par la suite, les r√®gles de s√©curit√© CORS sont appliqu√©es via l'utilisation de la fonction \texttt{CORS}.

Des variables globales sont ensuite d√©clar√©es, notamment l'URL de l'API du mod√®le et le nom du mod√®le √† utiliser. Puis, la logique du traitement repose sur une route principale, charg√©e de r√©ceptionner les requ√™tes envoy√©es sous forme JSON.

√Ä la r√©ception d'une requ√™te, l'application cr√©e un objet \texttt{ClaimExtractor}, charg√© du traitement textuel √† l'aide de techniques de NLP. Elle instancie ensuite un objet \texttt{Prompt}, puis un objet \texttt{OllamaAPI}. Le prompt est g√©n√©r√©, transmis √† l'objet \texttt{OllamaAPI}, lequel l'envoie au mod√®le d'IA pour traitement final. Une fois la r√©ponse obtenue, elle est imm√©diatement renvoy√©e au client, et le processus associ√© est d√©truit automatiquement.
\subsubsection*{Description des Classes Impl√©ment√©es dans le Backend}
\begin{description}
    \item \textbf{ClaimExtractor : Traitement linguistique et extraction d'informations}
La classe \texttt{ClaimExtractor} constitue une composante centrale du traitement du langage dans notre application. Elle a √©t√© impl√©ment√©e dans le but d'extraire des √©l√©ments significatifs √† partir d'un texte brut. Ce traitement repose sur des techniques de NLP (NLP), appliqu√©es √† travers diff√©rentes √©tapes telles que :
\begin{itemize}
    \item le pr√©traitement lexical,
    \item le nettoyage syntaxique (suppression des emojis, ponctuation, etc.),
    \item l'analyse s√©mantique ou extraction de faits et entit√©s.
\end{itemize}
Son objectif est de transformer une donn√©e textuelle brute en une structure exploitable, qui servira de base √† la g√©n√©ration du prompt.

\textbf{R√¥le dans le flux :} Cette classe est instanci√©e d√®s la r√©ception du texte utilisateur. Elle r√©alise un premier traitement de fond et renvoie un contenu structur√© adapt√© √† la suite du processus.
\begin{itemize}
   

\begin{figure}
    \centering
    \includegraphics[height=12cm,width=1\linewidth]{images/Screenshot 2025-06-21 171813.png} 
    \caption{ClaimExtractor Class} % Combined caption
    \label{fig:logos} % Corrected label
    
\end{figure}

\begin{figure}
    \centering
    \includegraphics[height=12cm,width=1\linewidth]{images/Screenshot 2025-06-21 173239.png} 
    \caption{ClaimExtractor Class} % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\newpage

\begin{figure}
  
    \includegraphics[height=5cm,width=1\linewidth]{images/Screenshot 2025-06-21 171908.png} 
    \caption{ClaimExtractor Class} % Combined caption
    \label{fig:logos} % Corrected label
\end{figure}
\vspace{-0.5cm}
\subsubsection{Description de la Classe ClaimExtractor}
La classe \texttt{ClaimExtractor} est un composant fondamental du module de traitement linguistique. Elle est con√ßue pour analyser un texte en langage naturel, identifier les √©nonc√©s pouvant √™tre consid√©r√©s comme des \textit{claims} (affirmations ou propositions v√©rifiables), puis les classifier en fonction de leur contenu s√©mantique. Cette classe repose principalement sur l'utilisation de la biblioth√®que \textbf{Stanza}, d√©velopp√©e par Stanford pour le NLP (NLP), ainsi que sur les biblioth√®ques \texttt{re} (expressions r√©guli√®res) et \texttt{emoji}.

\subsubsection*{1. \texttt{re} --- Biblioth√®que d'expressions r√©guli√®res}
La biblioth√®que \texttt{re} (abr√©viation d'expressions r√©guli√®res) est un module natif de Python qui permet d'effectuer des op√©rations avanc√©es de traitement de texte. Elle permet notamment de :
\begin{itemize}
    \item rechercher des motifs dans une cha√Æne de caract√®res (\textit{matching}),
    \item extraire ou remplacer certains segments selon des mod√®les d√©finis,
    \item valider des codes (e-mails, URL, num√©ros, etc.),
    \item effectuer des nettoyages textuels.
\end{itemize}
Dans ce projet, \texttt{re} est utilis√©e pour supprimer les URLs, mentions, caract√®res sp√©ciaux et pour normaliser le texte avant le traitement linguistique.

\subsubsection*{2. Stanza --- Outil de NLP (NLP)}
\textbf{Stanza} est une biblioth√®que NLP d√©velopp√©e par l'Universit√© de Stanford. Elle permet d'analyser le langage humain de mani√®re structur√©e √† travers plusieurs modules linguistiques comme :
\begin{itemize}
    \item la tokenisation (d√©coupage du texte en mots et phrases),
    \item le POS tagging (√©tiquetage des cat√©gories grammaticales),
    \item la reconnaissance d'entit√©s nomm√©es (NER),
    \item la lemmatisation, la d√©pendance syntaxique, et bien d'autres.
\end{itemize}
Son principal avantage est son support multilingue et la qualit√© de ses mod√®les bas√©s sur les r√©seaux de neurones.

Dans cette application, Stanza est utilis√© pour analyser les phrases et extraire des informations grammaticales et s√©mantiques n√©cessaires √† l'identification des \textit{claims}.

\subsubsection*{3. Emoji --- Gestion des emojis dans le texte}
Le module \texttt{emoji} est une biblioth√®que Python qui permet de convertir les emojis en texte lisible et inversement. Il est particuli√®rement utile pour :
\begin{itemize}
    \item remplacer les emojis par leur description textuelle (exemple : üòÄ $\rightarrow$ \texttt{:grinning\_face:}),
    \item reconna√Ætre ou filtrer les emojis dans une cha√Æne de caract√®res.
\end{itemize}
Dans le contexte de ce projet, la fonction \texttt{emoji.demojize()} est utilis√©e pour transformer les emojis en leur √©quivalent textuel.


\subsubsection*{M√©thodes et Fonctionnalit√©s R√©sum√©es}

\begin{enumerate}
    \item \textbf{\texttt{\_\_init\_\_}(self, lang="en")}  
    Initialise le pipeline Stanza pour la langue choisie, activant tokenisation, POS-tagging et NER. L√®ve une exception en cas d‚Äô√©chec.

    \item \textbf{\texttt{Clean\_text}(self, content)}  
    Nettoie le texte brut en supprimant URL, mentions, caract√®res sp√©ciaux, convertit hashtags et emojis en texte, et uniformise les espaces, pour pr√©parer une analyse NLP fiable.

    \item \textbf{\texttt{Is\_claim}(self, sentence)}  
    D√©termine si une phrase est un \textit{claim} selon des crit√®res : longueur, pr√©sence de verbe, entit√©s nomm√©es ou quantitatifs, et exclusion des phrases subjectives. Retourne un bool√©en et une justification.

    \item \textbf{\texttt{Classify\_claim}(self, text)}  
    Classe un \textit{claim} en cat√©gories pr√©d√©finies (\texttt{expressive\_false}, \texttt{true}, \texttt{expressive\_true}) ou par d√©faut \texttt{neutral}, selon des mots-cl√©s.

    \item \textbf{\texttt{Compute\_confidence}(self, sentence, label)}  
    Calcule un score de confiance (entre 0.5 et 1.0) bas√© sur la structure de la phrase, la pr√©sence d‚Äôun verbe, d‚Äôentit√©s, et la classification du \textit{claim}.

    \item \textbf{\texttt{Extract\_claims}(self, content)}  
    M√©thode principale combinant nettoyage, analyse NLP, d√©tection, classification et √©valuation des \textit{claims}. Retourne une liste enrichie avec texte, entit√©s, classe, score de confiance et motif de s√©lection.
\end{enumerate}


\end{description}
\subsubsection{Classe Prompt --- G√©n√©ration du texte d'instruction pour le mod√®le IA}
\begin{description}
\item[Classe Prompt --- G√©n√©ration du texte d'instruction pour le mod√®le IA]
La classe \texttt{Prompt} est con√ßue pour formuler dynamiquement une consigne (ou \textit{prompt}) destin√©e √† un mod√®le d'intelligence artificielle. Elle int√®gre une affirmation (\texttt{claim\_text}) dans une structure de texte pr√©d√©finie, utilis√©e pour questionner le mod√®le sur la v√©racit√© ou la nature de cette affirmation.
\end{description}

\subsubsection*{Structure et fonctionnement :}

\begin{enumerate}
    \item \textbf{M√©thode \texttt{\_\_init\_\_}(self, claim\_text) :}
    Cette m√©thode d'initialisation :
    \begin{itemize}
        \item prend en param√®tre un texte \texttt{claim\_text} (affirmation √† √©valuer),
        \item ins√®re ce texte dans une instruction structur√©e en anglais destin√©e √† un mod√®le de type s√©mantique,
        \item convertit l'ensemble du \textit{prompt} en minuscules pour normaliser l'entr√©e.
    \end{itemize}

    \textbf{Exemple de texte g√©n√©r√© :}
    \begin{verbatim}
    he is an expert in verifying the capabilities.
    Evaluation of affirmation and responses.
    Affirmation: "that is a real claim"
    1. Simply tell me if is this declaration: authentic / fake / 
    expressively fake / expressively true?
    2. Without supplying any explanation
    \end{verbatim}
    Cela permet d'uniformiser les requ√™tes envoy√©es au mod√®le et de forcer une r√©ponse ferm√©e (sans justification), facilitant la classification automatique.

    \item \textbf{M√©thode \texttt{get\_prompt}(self) :} % Renamed to get_prompt for clarity, based on common Python practices
    Retourne simplement la cha√Æne de caract√®res g√©n√©r√©e et stock√©e dans \texttt{self.text}. % Renamed self.Textual content to self.text for Python convention
    


\subsubsection*{Utilit√© dans l'architecture de l'application}
Cette classe permet d'encapsuler la logique de cr√©ation de prompts clairs et coh√©rents, ce qui est crucial dans une architecture de type NLP + LLM. Elle sert de pont entre l'extraction de donn√©es (\textit{claims}) et leur interpr√©tation par un mod√®le.
     
\end{enumerate}

\end{description}
\subsubsection{Classe OllamaAPI et architecture backend NLP/LLM}

\begin{description}

\item[] \textbf{1. Classe OllamaAPI}  
Interface assurant la communication entre le backend Flask et un mod√®le de langage local LLaMA 3 (3 milliards de param√®tres) via une API REST locale.

\item[] \textbf{2. Fonctionnalit√© principale}  
Envoi d‚Äôun \textit{prompt} par requ√™te HTTP POST et r√©ception de la r√©ponse textuelle, avec gestion des erreurs r√©seau via la biblioth√®que Python \texttt{requests}.

\item[] \textbf{3. Structure}  
\begin{itemize}
    \item \texttt{\_\_init\_\_} : initialise l‚ÄôURL de l‚ÄôAPI et le nom du mod√®le.
    \item \texttt{generate\_response(prompt)} : construit la requ√™te, l‚Äôenvoie, r√©cup√®re la r√©ponse et g√®re les exceptions.
\end{itemize}

\item[] \textbf{4. R√¥le dans l‚Äôarchitecture}  
Intervient entre la g√©n√©ration du prompt (classe \texttt{Prompt}) et la r√©ponse finale, permettant une interrogation dynamique et modulaire du mod√®le via REST.

\item[] \textbf{5. Avantages}  
Modularit√© (adaptable √† d‚Äôautres API), robustesse (gestion d‚Äôerreurs), et flexibilit√© (modification simple du mod√®le ou de l‚ÄôURL).

\item[] \textbf{6. Synth√®se backend NLP/LLM}  
Le backend, bas√© sur Flask, int√®gre plusieurs modules sp√©cialis√©s :  
\begin{itemize}
    \item \texttt{ClaimExtractor} : analyse textuelle (tokenisation, POS, NER) avec Stanza, nettoyage du texte et classification des affirmations avec score de confiance.
    \item \texttt{Prompt} : g√©n√®re une invite standardis√©e destin√©e au LLM.
    \item \texttt{OllamaAPI} : communique avec le mod√®le local LLaMA 3 via API REST.
\end{itemize}
Une unique route Flask g√®re la cha√Æne compl√®te : r√©ception du texte, analyse NLP, g√©n√©ration du prompt, interrogation du mod√®le, et retour de la r√©ponse.  
La configuration CORS garantit la communication s√©curis√©e entre frontend (extension Chrome) et backend.

\end{description}


\subsubsection*{Conclusion}
Ce back-end est une s√©quence coh√©rente de traitements visant √† la d√©tection et √† l'analyse automatiques d'instructions textuelles. Il utilise des principes de pointe en NLP et en g√©n√©ration de langage, et respecte les principes d'encapsulation, de modularit√© et de robustesse logicielle, caract√©ristiques des meilleures pratiques en g√©nie logiciel acad√©mique.
\end{description}


\subsection{L'Extension Chrome}

\begin{description}
    \item[1. Architecture Globale] 
    \begin{itemize}
        \item \textbf{Extension Chrome Facebook}
        \begin{itemize}
            \item \textit{Configuration} : \texttt{manifest.json}
            \item \textit{Interface} : \texttt{popup.html, popup.js, popup.css}
            \item \textit{Logique} : \texttt{content-script.js, background.js}
            \item \textit{Services} : d√©tection, analyse, cache, affichage
            \item \textit{Ressources} : dossier \texttt{icons/}
        \end{itemize}
    \end{itemize}
    
    \item[2. Composants Cl√©s]
    \begin{itemize}
        \item \textbf{Manifeste} : m√©tadonn√©es, permissions, scripts, contextes
        \item \textbf{Scripts principaux}
        \begin{itemize}
            \item \texttt{content-script.js} : d√©tection posts, extraction, API, injection r√©sultats
            \item \texttt{background.js} : gestion cycle de vie, communication, √©tat global
        \end{itemize}
        \item \textbf{Interface utilisateur} : contr√¥le via \texttt{popup.html/js/css}
    \end{itemize}
    
    \item[3. Principaux M√©canismes Techniques]
    \begin{itemize}
        \item \textbf{Observation} : \texttt{MutationObserver} surveille le DOM et supprime √©l√©ments ind√©sirables
        \item \textbf{Cache} : stockage local avec expiration 24h, √©vite analyses r√©p√©t√©es
        \item \textbf{Communication} : messages internes et requ√™tes HTTP externes
        \item \textbf{Manipulation DOM} : extraction continue, injection homog√®ne, adaptation dynamique
    \end{itemize}
    
    \item[4. Consid√©rations Techniques]
    \begin{itemize}
        \item \textbf{Efficacit√©} : identifiants uniques, traitement asynchrone, gestion des files d‚Äôattente
        \item \textbf{Flexibilit√©} : architecture modulaire, s√©lecteurs CSS dynamiques
        \item \textbf{S√©curit√©} : isolation des contextes, validation des donn√©es, gestion s√©curis√©e
    \end{itemize}
\end{description}

\vspace{0.3cm}
Cette organisation modulaire garantit une extension performante, maintenable et √©volutive, adapt√©e aux changements de la plateforme Facebook.


\newline
\begin{description}

\subsubsection{Architecture et Configuration Extension Chrome}
 \begin{figure}[ht!]
    \centering
    \includegraphics[height=20cm,width=1\linewidth]{images/Screenshot 2025-06-23 124002.png}
    \caption{Interface d'Extention Chrome}
    \label{fig:enter-label}
    \end{figure}
    
\end{description}
\hspace{-1cm}
\subsubsection*{R√©sum√© des Composants du Fichier \texttt{manifest.json}}

Le fichier \texttt{manifest.json} constitue la d√©claration centrale d'une extension Chrome. Voici ses √©l√©ments principaux :

\begin{itemize}
    \item \textbf{M√©tadonn√©es} : \texttt{name}, \texttt{version}, \texttt{description}, \texttt{manifest\_version} d√©finissent l'identit√© et la structure du projet.
    
    \item \textbf{Permissions} : D√©clarent les acc√®s n√©cessaires (\texttt{storage}, \texttt{tabs}, \texttt{scripting}, \texttt{webRequest}) pour interagir avec le navigateur et les pages visit√©es.

    \item \textbf{Host Permissions} : Restreignent l'action de l‚Äôextension aux domaines cibl√©s (ex : Facebook).

    \item \textbf{Content Scripts} : Sp√©cifient les scripts inject√©s automatiquement sur certaines pages, avec leur moment d‚Äôex√©cution.

    \item \textbf{Background Script} : Assure le traitement en arri√®re-plan et la gestion des √©v√©nements persistants (\texttt{background.js} via \texttt{service\_worker}).

    \item \textbf{UI de l'extension} : D√©finie via \texttt{action}, elle inclut le popup d‚Äôinterface utilisateur et les info-bulles associ√©es.

    \item \textbf{S√©curit√©} : Le champ \texttt{content\_security\_policy} encadre strictement les sources de scripts ex√©cutables.

    \item \textbf{Ressources accessibles} : \texttt{web\_accessible\_resources} rend certaines ressources visibles depuis les pages cibl√©es par l‚Äôextension.

    \item \textbf{Ic√¥nes} : Utilis√©es pour repr√©senter visuellement l‚Äôextension dans l‚Äôinterface de Chrome.
\end{itemize}

\begin{description}
    \item[Chrome DevTools:]\newline
\end{description}

\begin{figure}[h]
    \centering
    \includegraphics[height=7cm,width=0.7\linewidth]{images/7-ways-pardot-users-can-use-chrome-developer-tools-copy.jpg}
    \caption{Chrome DevTools}
    \label{fig:enter-label}
    \end{figure}
    \vspace{-1cm}
\subsubsection{Utilisation des Chrome DevTools dans le D√©veloppement d'une Extension Chrome d'Analyse de Publications Facebook}
\vspace{0.3cm}
\subsubsection*{ Usage de Chrome DevTools dans le D√©veloppement de l'Extension}

\begin{specialpar}
\textbf{Chrome DevTools} constitue un environnement int√©gr√© essentiel pour le d√©veloppement, l‚Äô√©valuation et l‚Äôoptimisation d‚Äôextensions web. Dans le cadre du projet d‚Äôanalyse automatique des publications Facebook, ces outils ont √©t√© exploit√©s √† diff√©rentes √©tapes du cycle de vie de l‚Äôextension :
\end{specialpar}

\begin{itemize}
  \item \textbf{Console} : pour le suivi de l‚Äôex√©cution, la journalisation des traitements et le test direct des scripts.
  \item \textbf{Inspecteur d‚Äô√âl√©ments} : pour analyser le DOM de Facebook, v√©rifier l‚Äôinjection des r√©sultats et tester les r√®gles CSS.
  \item \textbf{Sources Panel} : pour d√©boguer le script \texttt{content-script.js} en temps r√©el et observer le flux d‚Äôanalyse.
  \item \textbf{Network Panel} : pour contr√¥ler les √©changes avec l‚ÄôAPI Flask et diagnostiquer les erreurs de communication.
  \item \textbf{Application Panel} : pour g√©rer et inspecter le cache local (\texttt{localStorage}) utilis√© dans l‚Äôextension.
  \item \textbf{Extensions Panel} : pour superviser l‚Äô√©tat de l‚Äôextension, ses erreurs, et effectuer des rechargements rapides.
  \item \textbf{Performance Panel} : pour mesurer l‚Äôimpact de l‚Äôextension sur la r√©activit√© de l‚Äôinterface Facebook.
  \item \textbf{Memory Panel} : pour analyser l‚Äôusage m√©moire et pr√©venir les fuites dues aux structures de donn√©es internes.
\end{itemize}

\begin{specialpar}
En synth√®se, \textbf{Chrome DevTools} a jou√© un r√¥le critique dans le contr√¥le qualit√© de l‚Äôextension, garantissant √† la fois sa robustesse fonctionnelle et sa performance globale.
\end{specialpar}


\begin{description}
 \begin{specialpar}
      \item Script Extension Chrome d'Analyse de Posts Facebook
 \end{specialpar}
\end{description} \begin{description}
  
\subsubsection{Description Technique du Script \texttt{contentscript.js} Responsable de l'Interaction avec les Publications Facebook}

Le fichier \texttt{contentscript.js} constitue le c≈ìur fonctionnel d'une extension de navigateur d√©di√©e √† l‚Äôanalyse automatique du contenu textuel des publications Facebook. Il repose sur l‚Äôobservation dynamique du DOM, une logique de cache locale, ainsi qu‚Äôun syst√®me modulaire et asynchrone d‚Äôinteractions r√©seau. Voici les principaux composants techniques du script :

\begin{itemize}
    \item \textbf{Gestion des √©tats de traitement} :
    \begin{itemize}
        \item \texttt{pendingPosts} : stocke les identifiants des publications en cours d‚Äôanalyse.
        \item \texttt{processedPosts} : conserve les publications d√©j√† trait√©es pour √©viter les doublons.
        \item \texttt{observedPosts} : √©vite la r√©-observation des m√™mes √©l√©ments DOM.
    \end{itemize}

    \item \textbf{M√©canisme de cache local} :
    \begin{itemize}
        \item Bas√© sur \texttt{localStorage}, avec des cl√©s g√©n√©r√©es par hachage du texte.
        \item Expiration des entr√©es au bout de 24 heures.
        \item Fonctions \texttt{loadCache} et \texttt{saveCache} pour la gestion du cache.
    \end{itemize}

    \item \textbf{Extraction s√©mantique du contenu} :
    \begin{itemize}
        \item La fonction \texttt{extractMainPostContent} isole le contenu principal en filtrant les sections non pertinentes.
        \item En cas d‚Äô√©chec, une m√©thode alternative assemble le texte √† partir des n≈ìuds \texttt{div} avec l‚Äôattribut \texttt{dir="auto"}.
    \end{itemize}

    \item \textbf{Identification et filtrage contextuel} :
    \begin{itemize}
        \item Fonctions \texttt{isComment} et \texttt{isSubElement} pour exclure les commentaires et composants secondaires.
    \end{itemize}

    \item \textbf{G√©n√©ration d‚Äôidentifiants stables} :
    \begin{itemize}
        \item Chaque publication re√ßoit un identifiant unique via \texttt{generateUniquePostId}, bas√© sur un hachage du texte.
    \end{itemize}

    \item \textbf{Injection et visualisation des r√©sultats} :
    \begin{itemize}
        \item La fonction \texttt{injectResult} affiche les r√©sultats directement dans la page.
        \item Un code couleur (vert pour "vrai", rouge pour "faux") facilite la compr√©hension imm√©diate.
    \end{itemize}

    \item \textbf{Analyse et appel distant} :
    \begin{itemize}
        \item Utilisation d‚Äôune API locale (Flask) via \texttt{analyzePostWithId}.
        \item En cas d‚Äôerreur, un message de secours est affich√©.
    \end{itemize}

    \item \textbf{D√©tection des contenus dynamiques} :
    \begin{itemize}
        \item Utilisation de \texttt{MutationObserver} dans \texttt{setupScrollObserver} pour d√©tecter les publications charg√©es dynamiquement.
    \end{itemize}

    \item \textbf{Int√©gration avec l‚Äôextension} :
    \begin{itemize}
        \item √âcoute des messages via \texttt{chrome.runtime.onMessage} pour vider le cache ou relancer l‚Äôanalyse.
    \end{itemize}

    \item \textbf{Initialisation du processus} :
    \begin{itemize}
        \item La fonction \texttt{initialize} est ex√©cut√©e apr√®s le chargement du DOM.
        \item Elle orchestre : le chargement du cache, l‚Äôactivation de l‚Äôobservateur, le traitement initial, et la planification p√©riodique.
    \end{itemize}
\end{itemize}

\subsubsection*{ Conclusion}

Le script \texttt{contentscript.js} constitue un composant essentiel d‚Äôune extension de navigateur orient√©e vers l‚Äôanalyse automatique des contenus sur les r√©seaux sociaux. Il combine plusieurs techniques avanc√©es : observation dynamique du DOM, filtrage s√©mantique, gestion optimis√©e du cache local, et appels r√©seau efficaces. Gr√¢ce √† sa structure modulaire et √† l‚Äôexternalisation de l‚Äôanalyse via une API d√©di√©e, il garantit √† la fois √©volutivit√©, maintenabilit√© et r√©activit√©. Ce script illustre ainsi la pertinence d‚Äôune solution technique l√©g√®re au service de l‚Äôenrichissement de l‚Äôexp√©rience utilisateur, notamment pour la v√©rification, l‚Äôassistance contextuelle ou la mod√©ration en ligne.



\subsubsection*{R√¥le de \texttt{background.js}}
Le fichier \texttt{background.js} est un √©l√©ment \textbf{essentiel} √† l'extension. Il est responsable de la \textbf{persistance des donn√©es}, de la \textbf{gestion des √©v√©nements li√©s au cycle de vie} de l'extension, et de l'\textbf{automatisation de la purge du cache}. Il repr√©sente le c≈ìur logique de l'extension, assurant la synchronisation des requ√™tes entrantes et la continuit√© des op√©rations, m√™me lorsque l'utilisateur n'interagit pas directement avec l'interface de l'extension.
\subsubsection*{R√¥le de \texttt{popup.js}}
Le fichier \texttt{popup.js} constitue l'\textbf{interface utilisateur centrale et interactive} de l'extension. Il offre une \textbf{visualisation dynamique} des statistiques du cache, permet une \textbf{gestion directe} de celui-ci (comme le vidage), et peut d√©clencher des processus d'analyse via une interaction directe avec la page active. Son int√©gration fluide dans l'environnement de Chrome et sa capacit√© √† r√©agir aux √©v√©nements utilisateurs renforcent son \textbf{efficacit√© fonctionnelle et ergonomique}.

\subsubsection*{Contribution et Perspectives}
Cette extension, issue d'un d√©veloppement collectif, illustre une \textbf{application syst√©matique des meilleures pratiques} de d√©veloppement web pour les navigateurs modernes, en exploitant pleinement les API de Chrome. Elle a √©t√© con√ßue pour √™tre \textbf{l√©g√®re, s√©curis√©e, √©volutive et centr√©e sur l'utilisateur}. Gr√¢ce √† ses fonctionnalit√©s asynchrones, sa gestion optimale des √©tats et son interop√©rabilit√© avec l'environnement du navigateur, elle repr√©sente une \textbf{avanc√©e technique} √† la hauteur des standards √©tablis en mati√®re de d√©veloppement d'extensions, offrant une base solide pour des √©volutions futures en mati√®re d'assistance informationnelle, de v√©rification des faits ou de mod√©ration de contenu.

\subsubsection{Conclusion G√©n√©rale sur l'Extension Chrome}

L'extension Chrome d√©velopp√©e dans ce projet se caract√©rise par une \textbf{architecture modulaire coh√©rente}, int√©grant de mani√®re efficace les scripts d'arri√®re-plan, les interfaces utilisateur et les scripts de contenu. Son objectif principal est l'\textbf{analyse}, la \textbf{gestion du cache} et l'\textbf{interaction contextuelle} avec des pages web sp√©cifiques, notamment les plateformes de m√©dias sociaux telles que Facebook ou Meta.
\subsection{R√©alisation Technique ‚Äì Int√©gration de Ollama et du mod√®le LLaMA 3.2}

Dans le cadre de ce projet, un des √©l√©ments essentiels de la r√©alisation technique concerne l'int√©gration d'un mod√®le de langage performant, capable d'√©valuer la fiabilit√© d'un contenu textuel extrait de r√©seaux sociaux. Pour r√©pondre √† ce besoin, le choix s'est port√© sur le mod√®le \textbf{LLaMA 3.2} (version 3B), accessible via un serveur \textbf{Ollama} d√©ploy√© en local.

---

\subsubsection*{1. Justification du choix technologique}
Le choix de LLaMA 3.2 repose sur plusieurs crit√®res cl√©s :
\begin{itemize}
    \item \textbf{Pertinence linguistique} : Ce mod√®le a √©t√© sp√©cifiquement entra√Æn√© sur de vastes corpus textuels, lui conf√©rant une capacit√© av√©r√©e √† comprendre le langage courant, les structures argumentatives et les formulations typiques des publications en ligne.
    \item \textbf{Taille √©quilibr√©e (3B)} : La version 3B de LLaMA offre un compromis optimal entre la qualit√© d'analyse et la consommation de ressources. Ceci est un facteur crucial pour une ex√©cution efficace en local ou sur un serveur de petite taille.
    \item \textbf{Open-source} : Contrairement √† certains mod√®les propri√©taires, LLaMA est accessible sous licence libre. Cette caract√©ristique facilite grandement son d√©ploiement et son int√©gration dans des projets acad√©miques, sans d√©pendre de services cloud commerciaux souvent on√©reux ou restrictifs.
    \item \textbf{Compatibilit√© avec Ollama} : Ollama se pr√©sente comme une solution l√©g√®re et performante pour lancer des mod√®les LLM localement. Il fournit une API simple et intuitive, permettant un dialogue rapide et efficace entre notre backend et le mod√®le de langage.
\end{itemize}

\subsubsection*{2. D√©ploiement du serveur Ollama}
Pour h√©berger et rendre accessible le mod√®le LLaMA, un serveur Ollama a √©t√© install√© et configur√© sur une machine locale d√©di√©e. Ollama permet d'ex√©cuter le mod√®le LLaMA comme un service accessible via des requ√™tes HTTP. Le processus d'installation a impliqu√© les √©tapes suivantes :
\begin{itemize}
    \item Installation du binaire Ollama.
    \item T√©l√©chargement du mod√®le LLaMA 3.2 (sous forme de fichier \texttt{.gguf}).
    \item D√©marrage du serveur local sur un port sp√©cifique.
    \item Configuration des routes d'acc√®s n√©cessaires pour la communication avec le backend de l'extension.
\end{itemize}
Une fois d√©ploy√©, le serveur Ollama est pr√™t √† recevoir des \textbf{prompts} (requ√™tes textuelles structur√©es) envoy√©s par le backend via des requ√™tes \texttt{POST}. En retour, il fournit le texte g√©n√©r√© par le mod√®le.


\subsubsection*{3. Int√©gration avec le backend}
Le backend de l'extension, d√©velopp√© en Python avec le framework Flask, assure une communication directe avec le serveur Ollama. Lorsqu'un post est extrait du r√©seau social, son contenu est d'abord analys√© linguistiquement (NLP ), puis un \textbf{prompt structur√©} est soigneusement construit √† partir de cette analyse. Ce prompt est ensuite envoy√© au serveur Ollama.

Exemple simplifi√© de prompt construit :
\begin{verbatim}
Question: Le texte suivant est-il fiable ou non fiable ? 
"√âvalue la v√©racit√© de l'affirmation suivante :
"Le citron peut gu√©rir le cancer."
Donne un verdict clair : Cr√©dible, Douteux ou Faux.
"
Reponse:
\end{verbatim}
Ollama transmet ce prompt au mod√®le LLaMA, qui g√©n√®re une r√©ponse sous forme de texte brut. Le backend est ensuite charg√© d'interpr√©ter cette r√©ponse et d'en extraire la classification finale (fiable/non fiable) qui sera affich√©e dans l'extension Chrome pour l'utilisateur.

\subsubsection*{4. R√©sultats obtenus}
L'int√©gration du mod√®le LLaMA 3.2 via Ollama a apport√© plusieurs avantages significatifs :
\begin{itemize}
    \item \textbf{R√©duction du temps de r√©ponse} : Le temps de r√©ponse moyen pour l'analyse d'un post a √©t√© r√©duit √† moins de 3 secondes, garantissant une exp√©rience utilisateur fluide.
    \item \textbf{Confidentialit√© des donn√©es} : En √©vitant les appels √† des services cloud externes, la confidentialit√© des donn√©es trait√©es est enti√®rement pr√©serv√©e, un aspect crucial pour ce type de projet.
    \item \textbf{Stabilit√© du syst√®me} : Le syst√®me a d√©montr√© une meilleure stabilit√© lors des tests √† grande √©chelle, gr√¢ce √† l'ex√©cution locale du mod√®le.
\end{itemize}
\subsubsection*{Conclusion}
Le choix strat√©gique d'utiliser Ollama avec le mod√®le LLaMA 3.2 s'est av√©r√© particuli√®rement judicieux pour un projet acad√©mique comme celui-ci, n√©cessitant √† la fois \textbf{flexibilit√©}, \textbf{pr√©cision linguistique} et un \textbf{contr√¥le total} sur l'environnement technique. Ce duo technologique a permis d'int√©grer un traitement intelligent et sophistiqu√© dans l'extension, tout en garantissant des performances satisfaisantes et une exp√©rience utilisateur finale optimale.



\section*{Conclusion}
La mise en ≈ìuvre du syst√®me d√©crit dans ce projet a constitu√© une √©tape importante, traduisant les sp√©cifications conceptuelles pr√©c√©demment d√©finies en une solution int√©gr√©e, fonctionnelle et pr√™te √† l'emploi. Ce chapitre a permis de mettre en √©vidence l'interaction harmonieuse des diff√©rents composants du syst√®me ‚Äì l'extension Chrome, le serveur backend d√©velopp√© en Python/Flask, ainsi que le moteur d'analyse s√©mantique bas√© sur un mod√®le de langage √©tendu (LLaMA 3.2) via le serveur Ollama ‚Äì pour fournir un service automatis√© de v√©rification des faits sur les r√©seaux sociaux.

Sur le plan technique, l'architecture distribu√©e mise en ≈ìuvre a favoris√© la modularit√©, la maintenabilit√© et l'√©volutivit√© du syst√®me. L'extension Chrome fonctionne comme un d√©tecteur intelligent de contenu textuel dans l'environnement de navigation, tandis que le backend g√®re le traitement linguistique et la coordination avec le moteur d'intelligence artificielle. L'int√©gration d'un syst√®me de mise en cache local am√©liore les performances en minimisant les traitements redondants.

De plus, l'utilisation de technologies modernes telles que Flask, JavaScript, API REST et JSON, combin√©e √† un environnement de d√©veloppement bien structur√©, a permis une ex√©cution s√©curis√©e, efficace et conforme du syst√®me, conform√©ment aux crit√®res fonctionnels et non fonctionnels d√©finis dans le chapitre pr√©c√©dent. Le syst√®me r√©pond √©galement aux exigences en mati√®re d'ergonomie, de r√©activit√© et de s√©curit√© des transferts de donn√©es.

Ainsi, la r√©alisation technique pr√©sent√©e dans ce chapitre valide √† la fois la faisabilit√© et la robustesse du syst√®me pr√©sent√©. Cela permet d'envisager des possibilit√©s d'extension, par exemple √† d'autres plateformes sociales, d'optimisation de l'algorithme d'intelligence artificielle, voire d'application globale de la solution √† un usage g√©n√©ralis√©.

